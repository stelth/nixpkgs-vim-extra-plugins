#!/usr/bin/env nix-shell
#!nix-shell update-shell.nix -i python

import argparse
import json
import re
import subprocess
from multiprocessing import Pool
from os import getenv
from os.path import join

lockfile = json.load(open(join(getenv("NVIM_TREESITTER"), "lockfile.json")))

configs = json.loads(
    subprocess.check_output(
        [
            "nvim",
            "--headless",
            "-u",
            "NONE",
            "+lua io.write(vim.json.encode(require('nvim-treesitter.parsers').get_parser_configs()))",
            "+quit!",
        ]
    )
)

regex = re.compile("^https?://(github.com|gitlab.com)/(.+?)/(.+?)(.git)?$")


def generate_grammar(item):
    lang, lock = item
    cfg = configs.get(lang)
    if not cfg:
        return ""

    info = cfg["install_info"]
    url = info["url"]
    rev = lock["revision"]

    generated = f"""  {lang} = buildGrammar {{
    language = "{lang}";
    version = "{rev[:7]}";
    source = """

    m = regex.fullmatch(url)
    cmd = ["nix-prefetch", "--rev", rev]

    match m and m.group(1, 2, 3):
        case "github.com", owner, repo:
            cmd += [
                "fetchFromGitHub",
                "--owner",
                owner,
                "--repo",
                repo,
            ]

            generated += f"""fetchFromGitHub {{
      owner = "{owner}";
      repo = "{repo}";"""

        case "gitlab.com", owner, repo:
            cmd += [
                "fetchFromGitLab",
                "--owner",
                owner,
                "--repo",
                repo,
            ]

            generated += f"""fetchFromGitLab {{
      owner = "{owner}";
      repo = "{repo}";"""

        case _:
            cmd += ["fetchgit", "url"]
            generated += f"""fetchgit {{
      url = "{url}";"""

    hash_code = subprocess.check_output(cmd, text=True).strip()

    generated += f"""
      rev = "{rev}";
      hash = "{hash_code}";
    }};"""

    location = info.get("location")
    if location:
        generated += f"""
    location = "{location}";"""

    if info.get("requires_generate_from_grammar"):
        generated += """
    generate = true;"""

    generated += f"""
    meta.homepage = "{url}";
  }};
"""

    return generated


DEFAULT_OUTFILE = "generated.nix"


def main():
    parser = argparse.ArgumentParser(
        description=(
            f"""
                Updates nix derivations for nvim-treesitter plugins.\n
                By default, saving to {DEFAULT_OUTFILE}
            """
        )
    )
    parser.add_argument(
        "--out",
        "-o",
        dest="outfile",
        default=DEFAULT_OUTFILE,
        help="Filename to save generated nix code",
    )
    parser.add_argument(
        "--proc",
        "-p",
        dest="proc",
        type=int,
        default=30,
        help="Number of concurrent processes to spawn.",
    )

    args = parser.parse_args()

    generated_file = []
    generated_file_header = """
    # generated by nvim-treesitter/update.py
    { buildGrammar, fetchFromGitHub, fetchFromGitLab, fetchgit, nodejs, tree-sitter }:
    {
    """
    with Pool(processes=args.proc) as pool:
        for generated in pool.map(generate_grammar, lockfile.items()):
            generated_file.append(generated)

    generated_file.sort()

    generated_file_footer = "}\n"

    with open(args.outfile, "w+", encoding="utf-8") as generated_grammars_file:
        generated_grammars_file.write(generated_file_header)
        generated_grammars_file.write("\n".join(generated_file))
        generated_grammars_file.write(generated_file_footer)


if __name__ == "__main__":
    main()
